/**************************************************************************/
void     sort_merge();
void     sort_merge_recursive();
void     backward_order();
long int cmp2rec();

/***************************************************************************/
// Цикл слияния двух цепочек в одну
void sliyanie(t_d_s *p_bb0, t_d_s *p_ff0, t_d_s *p_bb1, t_d_s *p_ff1, P_t_d_s &p_bb, P_t_d_s &p_ff) {

long  int fs;
t_d_s p_anc;
t_d_s *p_prev;

//t_d_s *p_bb0;
//t_d_s *p_bb1;
//t_d_s *p_ff0;
//t_d_s *p_ff1;
         
//  p_bb0 = p_bbb0;
//  p_bb1 = p_bbb1;
//  p_ff0 = p_fff0;
//  p_ff1 = p_fff1;

  p_prev = &p_anc;

  while (1) {

    fs = cmp2rec(p_bb0, p_bb1);

    if (fs < 0) {                     //   // Сравниваем текущие Эл.1 ЛМ и Эл.2 ПМ
      p_prev->p_poi[1] = p_bb0;       //   // Последний элемент слитого массива теперь указывает на Эл.1 победителя
      if (p_bb0 == p_ff0) {           // Р // Коли дошли до конца одного из сливаемых массивов
        p_bb0->p_poi[1] = p_bb1;      // Р //   Цепляем оставшийся хвост  
        p_ff            = p_ff1;      // Р //   Запоминаем последний элемент  
        break;                        //   //   Выход из цикла
      }                               //   //     
      p_prev = p_bb0;                 //   // Эл.1 Победителя сам становится последним элементом слитого массива
      p_bb0  = p_prev->p_poi[1];      // Р // Эл.2 победителя становится Эл.1
    }                                      
    else {                                 
      p_prev->p_poi[1] = p_bb1;       //   // Последний элемент слитого массива теперь указывает на Эл.1 победителя
      if (p_bb1 == p_ff1) {           // Р // Коли дошли до конца одного из сливаемых массивов
        p_bb1->p_poi[1] = p_bb0;      // Р //   Цепляем оставшийся хвост  
        p_ff            = p_ff0;      // Р //   Запоминаем последний элемент  
        break;                        //   //   Выход из цикла
      }                               //   //     
      p_prev = p_bb1;                 //   // Эл.1 Победителя сам становится последним элементом слитого массива
      p_bb1  = p_prev->p_poi[1];      // Р // Эл.2 победителя становится Эл.1
    }
  }
  p_bb = p_anc.p_poi[1];              //   // Начало слитой цепочки - всегда здесь (в ячейке poi[1])

}

/**************************************************************************/
void sort_merge_recursive(P_t_d_s &p_b, P_t_d_s &p_f) {

t_d_s  *p_b2;
t_d_s  *p_f2;
t_d_s  *p_b_x;
t_d_s  *p_f_x;

  if (p_b == p_f) {
    return;
  }

  //   Деление пополам.
  // p_f_x двигается от p_f влево.
  // p_b_x двигается от p_b вправо.

  for (p_b_x = p_b, p_f_x = p_f; ;  ) {
    if (p_b_x->p_poi[1] == p_f_x) 
      break;
    p_b_x = p_b_x->p_poi[1];
    
    if (p_f_x->p_poi[0] == p_b_x) 
      break;
    p_f_x = p_f_x->p_poi[0];
  }

  p_b2 = p_b_x;  p_f2 = p_f_x;

// Внимание на будущее!
//
// Поскольку p_b2 и p_f2 передаются в sort_merge_recursive по хитрому как "указатели на указатели", 
// их никак невозможно держать на регистрах.
// Поэтому в цикле используются p_b_x и p_f_x, которые потом присваиваются в p_b2 и p_f2.

// Две сортировки двух половинок

  sort_merge_recursive(p_b , p_b2);
  sort_merge_recursive(p_f2, p_f );

  // Слияние двух цепочек в одну - [p_b, p_f]
  sliyanie(p_b, p_b2, p_f2, p_f, p_b, p_f);

  // p_b и p_f - входные указатели на входной массив, который мы разбили на две равные половинки, 
  // рекурсивно их отсортировали и слили в один отсортированный массив.
  // Эти два указателя могли измениться. 
  // Измененные указатели на слитый массив надо вернуть наверх.
}

/**************************************************************************/
void sort_merge(P_t_d_s &p_b, P_t_d_s &p_f) {
// Нисходящая сортировка слиениям.
// Весь массив делим на половинки, половинки - на четвертинки, потом на осьмушки и т.д., пока не дойдеи до двоек.
// И теперь с двоек начинаем обратное (восходящее) слиение вверх.

  sort_merge_recursive(p_b, p_f);
  backward_order(p_b, p_f);
}

/**************************************************************************/
void sort_merge_up(P_t_d_s &p_b, P_t_d_s &p_f) {       
// Восходящая сортировка слиянием.
// Отдельные элементы сливаем в двойки, двойки в четверки, четверки - в восьмерки и т.д.  

t_d_s *p_bb;
t_d_s *p_bb0;
t_d_s *p_bb1;

t_d_s *p_u0;
t_d_s *p_u1;

t_d_s *p_prev_chain;
t_d_s *p_i;

t_d_s *p_tmp;

  if (p_b == p_f) {
    return;
  }

  // Прописываем указатели
  for (p_i = p_b; p_i != NULL; p_i = p_i->p_poi[1]) {
    p_i->p_poi[2] = p_i;				// p_poi[2] - ссылка на конец текущей цепочки
    p_i->p_poi[3] = p_i->p_poi[1];                      // p_poi[3] - ссылка на начало след.цепочки
  }

  p_f->p_poi[3] = p_b;                                  // Замыкаем хвост на начало
  p_bb1         = p_f;                                  // Как бы из-за такта
  p_prev_chain  = p_f;

  while (1) {
    // Как минимум одно слияние должно произойти
    // Все замкнуто по кругу, нулевых указателей быть не может

    p_bb0 = p_bb1->p_poi[3];
    p_bb1 = p_bb0->p_poi[3];

    // Цикл слияния двух цепочек в одну
    sliyanie(p_bb0, p_bb0->p_poi[2], p_bb1, p_bb1->p_poi[2], p_u0, p_u1);

    p_bb           = p_u0;
    p_bb->p_poi[2] = p_u1;

    if (p_bb1 == p_prev_chain)
      break;

    // Связываем полученную слитую цепочку с предыдущей слитой цепочкой
    p_prev_chain->p_poi[3] = p_bb;    
    p_prev_chain           = p_bb;
  }

  p_b = p_bb;            p_f = p_bb->p_poi[2];

  backward_order(p_b, p_f);
}
